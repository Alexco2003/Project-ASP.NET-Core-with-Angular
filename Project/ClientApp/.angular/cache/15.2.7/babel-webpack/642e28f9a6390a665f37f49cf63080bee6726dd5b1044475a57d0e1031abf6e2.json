{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Alexco/Desktop/proiect .net/Project/Project/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { MessageType } from \"./IHubProtocol\";\nimport { isArrayBuffer } from \"./Utils\";\n/** @private */\nexport class MessageBuffer {\n  constructor(protocol, connection, bufferSize) {\n    this._bufferSize = 100000;\n    this._messages = [];\n    this._totalMessageCount = 0;\n    this._waitForSequenceMessage = false;\n    // Message IDs start at 1 and always increment by 1\n    this._nextReceivingSequenceId = 1;\n    this._latestReceivedSequenceId = 0;\n    this._bufferedByteCount = 0;\n    this._reconnectInProgress = false;\n    this._protocol = protocol;\n    this._connection = connection;\n    this._bufferSize = bufferSize;\n  }\n  _send(message) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const serializedMessage = _this._protocol.writeMessage(message);\n      let backpressurePromise = Promise.resolve();\n      // Only count invocation messages. Acks, pings, etc. don't need to be resent on reconnect\n      if (_this._isInvocationMessage(message)) {\n        _this._totalMessageCount++;\n        let backpressurePromiseResolver = () => {};\n        let backpressurePromiseRejector = () => {};\n        if (isArrayBuffer(serializedMessage)) {\n          _this._bufferedByteCount += serializedMessage.byteLength;\n        } else {\n          _this._bufferedByteCount += serializedMessage.length;\n        }\n        if (_this._bufferedByteCount >= _this._bufferSize) {\n          backpressurePromise = new Promise((resolve, reject) => {\n            backpressurePromiseResolver = resolve;\n            backpressurePromiseRejector = reject;\n          });\n        }\n        _this._messages.push(new BufferedItem(serializedMessage, _this._totalMessageCount, backpressurePromiseResolver, backpressurePromiseRejector));\n      }\n      try {\n        // If this is set it means we are reconnecting or resending\n        // We don't want to send on a disconnected connection\n        // And we don't want to send if resend is running since that would mean sending\n        // this message twice\n        if (!_this._reconnectInProgress) {\n          yield _this._connection.send(serializedMessage);\n        }\n      } catch {\n        _this._disconnected();\n      }\n      yield backpressurePromise;\n    })();\n  }\n  _ack(ackMessage) {\n    let newestAckedMessage = -1;\n    // Find index of newest message being acked\n    for (let index = 0; index < this._messages.length; index++) {\n      const element = this._messages[index];\n      if (element._id <= ackMessage.sequenceId) {\n        newestAckedMessage = index;\n        if (isArrayBuffer(element._message)) {\n          this._bufferedByteCount -= element._message.byteLength;\n        } else {\n          this._bufferedByteCount -= element._message.length;\n        }\n        // resolve items that have already been sent and acked\n        element._resolver();\n      } else if (this._bufferedByteCount < this._bufferSize) {\n        // resolve items that now fall under the buffer limit but haven't been acked\n        element._resolver();\n      } else {\n        break;\n      }\n    }\n    if (newestAckedMessage !== -1) {\n      // We're removing everything including the message pointed to, so add 1\n      this._messages = this._messages.slice(newestAckedMessage + 1);\n    }\n  }\n  _shouldProcessMessage(message) {\n    if (this._waitForSequenceMessage) {\n      if (message.type !== MessageType.Sequence) {\n        return false;\n      } else {\n        this._waitForSequenceMessage = false;\n        return true;\n      }\n    }\n    // No special processing for acks, pings, etc.\n    if (!this._isInvocationMessage(message)) {\n      return true;\n    }\n    const currentId = this._nextReceivingSequenceId;\n    this._nextReceivingSequenceId++;\n    if (currentId <= this._latestReceivedSequenceId) {\n      if (currentId === this._latestReceivedSequenceId) {\n        // Should only hit this if we just reconnected and the server is sending\n        // Messages it has buffered, which would mean it hasn't seen an Ack for these messages\n        this._ackTimer();\n      }\n      // Ignore, this is a duplicate message\n      return false;\n    }\n    this._latestReceivedSequenceId = currentId;\n    // Only start the timer for sending an Ack message when we have a message to ack. This also conveniently solves\n    // timer throttling by not having a recursive timer, and by starting the timer via a network call (recv)\n    this._ackTimer();\n    return true;\n  }\n  _resetSequence(message) {\n    if (message.sequenceId > this._nextReceivingSequenceId) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._connection.stop(new Error(\"Sequence ID greater than amount of messages we've received.\"));\n      return;\n    }\n    this._nextReceivingSequenceId = message.sequenceId;\n  }\n  _disconnected() {\n    this._reconnectInProgress = true;\n    this._waitForSequenceMessage = true;\n  }\n  _resend() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const sequenceId = _this2._messages.length !== 0 ? _this2._messages[0]._id : _this2._totalMessageCount + 1;\n      yield _this2._connection.send(_this2._protocol.writeMessage({\n        type: MessageType.Sequence,\n        sequenceId\n      }));\n      // Get a local variable to the _messages, just in case messages are acked while resending\n      // Which would slice the _messages array (which creates a new copy)\n      const messages = _this2._messages;\n      for (const element of messages) {\n        yield _this2._connection.send(element._message);\n      }\n      _this2._reconnectInProgress = false;\n    })();\n  }\n  _dispose(error) {\n    error !== null && error !== void 0 ? error : error = new Error(\"Unable to reconnect to server.\");\n    // Unblock backpressure if any\n    for (const element of this._messages) {\n      element._rejector(error);\n    }\n  }\n  _isInvocationMessage(message) {\n    // There is no way to check if something implements an interface.\n    // So we individually check the messages in a switch statement.\n    // To make sure we don't miss any message types we rely on the compiler\n    // seeing the function returns a value and it will do the\n    // exhaustive check for us on the switch statement, since we don't use 'case default'\n    switch (message.type) {\n      case MessageType.Invocation:\n      case MessageType.StreamItem:\n      case MessageType.Completion:\n      case MessageType.StreamInvocation:\n      case MessageType.CancelInvocation:\n        return true;\n      case MessageType.Close:\n      case MessageType.Sequence:\n      case MessageType.Ping:\n      case MessageType.Ack:\n        return false;\n    }\n  }\n  _ackTimer() {\n    var _this3 = this;\n    if (this._ackTimerHandle === undefined) {\n      this._ackTimerHandle = setTimeout( /*#__PURE__*/_asyncToGenerator(function* () {\n        try {\n          if (!_this3._reconnectInProgress) {\n            yield _this3._connection.send(_this3._protocol.writeMessage({\n              type: MessageType.Ack,\n              sequenceId: _this3._latestReceivedSequenceId\n            }));\n          }\n          // Ignore errors, that means the connection is closed and we don't care about the Ack message anymore.\n        } catch {}\n        clearTimeout(_this3._ackTimerHandle);\n        _this3._ackTimerHandle = undefined;\n        // 1 second delay so we don't spam Ack messages if there are many messages being received at once.\n      }), 1000);\n    }\n  }\n}\nclass BufferedItem {\n  constructor(message, id, resolver, rejector) {\n    this._message = message;\n    this._id = id;\n    this._resolver = resolver;\n    this._rejector = rejector;\n  }\n}","map":{"version":3,"names":["MessageType","isArrayBuffer","MessageBuffer","constructor","protocol","connection","bufferSize","_bufferSize","_messages","_totalMessageCount","_waitForSequenceMessage","_nextReceivingSequenceId","_latestReceivedSequenceId","_bufferedByteCount","_reconnectInProgress","_protocol","_connection","_send","message","serializedMessage","writeMessage","backpressurePromise","Promise","resolve","_isInvocationMessage","backpressurePromiseResolver","backpressurePromiseRejector","byteLength","length","reject","push","BufferedItem","send","_disconnected","_ack","ackMessage","newestAckedMessage","index","element","_id","sequenceId","_message","_resolver","slice","_shouldProcessMessage","type","Sequence","currentId","_ackTimer","_resetSequence","stop","Error","_resend","messages","_dispose","error","_rejector","Invocation","StreamItem","Completion","StreamInvocation","CancelInvocation","Close","Ping","Ack","_ackTimerHandle","undefined","setTimeout","clearTimeout","id","resolver","rejector"],"sources":["C:/Users/Alexco/Desktop/proiect .net/Project/Project/ClientApp/node_modules/@microsoft/signalr/dist/esm/MessageBuffer.js"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { MessageType } from \"./IHubProtocol\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n/** @private */\r\nexport class MessageBuffer {\r\n    constructor(protocol, connection, bufferSize) {\r\n        this._bufferSize = 100000;\r\n        this._messages = [];\r\n        this._totalMessageCount = 0;\r\n        this._waitForSequenceMessage = false;\r\n        // Message IDs start at 1 and always increment by 1\r\n        this._nextReceivingSequenceId = 1;\r\n        this._latestReceivedSequenceId = 0;\r\n        this._bufferedByteCount = 0;\r\n        this._reconnectInProgress = false;\r\n        this._protocol = protocol;\r\n        this._connection = connection;\r\n        this._bufferSize = bufferSize;\r\n    }\r\n    async _send(message) {\r\n        const serializedMessage = this._protocol.writeMessage(message);\r\n        let backpressurePromise = Promise.resolve();\r\n        // Only count invocation messages. Acks, pings, etc. don't need to be resent on reconnect\r\n        if (this._isInvocationMessage(message)) {\r\n            this._totalMessageCount++;\r\n            let backpressurePromiseResolver = () => { };\r\n            let backpressurePromiseRejector = () => { };\r\n            if (isArrayBuffer(serializedMessage)) {\r\n                this._bufferedByteCount += serializedMessage.byteLength;\r\n            }\r\n            else {\r\n                this._bufferedByteCount += serializedMessage.length;\r\n            }\r\n            if (this._bufferedByteCount >= this._bufferSize) {\r\n                backpressurePromise = new Promise((resolve, reject) => {\r\n                    backpressurePromiseResolver = resolve;\r\n                    backpressurePromiseRejector = reject;\r\n                });\r\n            }\r\n            this._messages.push(new BufferedItem(serializedMessage, this._totalMessageCount, backpressurePromiseResolver, backpressurePromiseRejector));\r\n        }\r\n        try {\r\n            // If this is set it means we are reconnecting or resending\r\n            // We don't want to send on a disconnected connection\r\n            // And we don't want to send if resend is running since that would mean sending\r\n            // this message twice\r\n            if (!this._reconnectInProgress) {\r\n                await this._connection.send(serializedMessage);\r\n            }\r\n        }\r\n        catch {\r\n            this._disconnected();\r\n        }\r\n        await backpressurePromise;\r\n    }\r\n    _ack(ackMessage) {\r\n        let newestAckedMessage = -1;\r\n        // Find index of newest message being acked\r\n        for (let index = 0; index < this._messages.length; index++) {\r\n            const element = this._messages[index];\r\n            if (element._id <= ackMessage.sequenceId) {\r\n                newestAckedMessage = index;\r\n                if (isArrayBuffer(element._message)) {\r\n                    this._bufferedByteCount -= element._message.byteLength;\r\n                }\r\n                else {\r\n                    this._bufferedByteCount -= element._message.length;\r\n                }\r\n                // resolve items that have already been sent and acked\r\n                element._resolver();\r\n            }\r\n            else if (this._bufferedByteCount < this._bufferSize) {\r\n                // resolve items that now fall under the buffer limit but haven't been acked\r\n                element._resolver();\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        if (newestAckedMessage !== -1) {\r\n            // We're removing everything including the message pointed to, so add 1\r\n            this._messages = this._messages.slice(newestAckedMessage + 1);\r\n        }\r\n    }\r\n    _shouldProcessMessage(message) {\r\n        if (this._waitForSequenceMessage) {\r\n            if (message.type !== MessageType.Sequence) {\r\n                return false;\r\n            }\r\n            else {\r\n                this._waitForSequenceMessage = false;\r\n                return true;\r\n            }\r\n        }\r\n        // No special processing for acks, pings, etc.\r\n        if (!this._isInvocationMessage(message)) {\r\n            return true;\r\n        }\r\n        const currentId = this._nextReceivingSequenceId;\r\n        this._nextReceivingSequenceId++;\r\n        if (currentId <= this._latestReceivedSequenceId) {\r\n            if (currentId === this._latestReceivedSequenceId) {\r\n                // Should only hit this if we just reconnected and the server is sending\r\n                // Messages it has buffered, which would mean it hasn't seen an Ack for these messages\r\n                this._ackTimer();\r\n            }\r\n            // Ignore, this is a duplicate message\r\n            return false;\r\n        }\r\n        this._latestReceivedSequenceId = currentId;\r\n        // Only start the timer for sending an Ack message when we have a message to ack. This also conveniently solves\r\n        // timer throttling by not having a recursive timer, and by starting the timer via a network call (recv)\r\n        this._ackTimer();\r\n        return true;\r\n    }\r\n    _resetSequence(message) {\r\n        if (message.sequenceId > this._nextReceivingSequenceId) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._connection.stop(new Error(\"Sequence ID greater than amount of messages we've received.\"));\r\n            return;\r\n        }\r\n        this._nextReceivingSequenceId = message.sequenceId;\r\n    }\r\n    _disconnected() {\r\n        this._reconnectInProgress = true;\r\n        this._waitForSequenceMessage = true;\r\n    }\r\n    async _resend() {\r\n        const sequenceId = this._messages.length !== 0\r\n            ? this._messages[0]._id\r\n            : this._totalMessageCount + 1;\r\n        await this._connection.send(this._protocol.writeMessage({ type: MessageType.Sequence, sequenceId }));\r\n        // Get a local variable to the _messages, just in case messages are acked while resending\r\n        // Which would slice the _messages array (which creates a new copy)\r\n        const messages = this._messages;\r\n        for (const element of messages) {\r\n            await this._connection.send(element._message);\r\n        }\r\n        this._reconnectInProgress = false;\r\n    }\r\n    _dispose(error) {\r\n        error !== null && error !== void 0 ? error : (error = new Error(\"Unable to reconnect to server.\"));\r\n        // Unblock backpressure if any\r\n        for (const element of this._messages) {\r\n            element._rejector(error);\r\n        }\r\n    }\r\n    _isInvocationMessage(message) {\r\n        // There is no way to check if something implements an interface.\r\n        // So we individually check the messages in a switch statement.\r\n        // To make sure we don't miss any message types we rely on the compiler\r\n        // seeing the function returns a value and it will do the\r\n        // exhaustive check for us on the switch statement, since we don't use 'case default'\r\n        switch (message.type) {\r\n            case MessageType.Invocation:\r\n            case MessageType.StreamItem:\r\n            case MessageType.Completion:\r\n            case MessageType.StreamInvocation:\r\n            case MessageType.CancelInvocation:\r\n                return true;\r\n            case MessageType.Close:\r\n            case MessageType.Sequence:\r\n            case MessageType.Ping:\r\n            case MessageType.Ack:\r\n                return false;\r\n        }\r\n    }\r\n    _ackTimer() {\r\n        if (this._ackTimerHandle === undefined) {\r\n            this._ackTimerHandle = setTimeout(async () => {\r\n                try {\r\n                    if (!this._reconnectInProgress) {\r\n                        await this._connection.send(this._protocol.writeMessage({ type: MessageType.Ack, sequenceId: this._latestReceivedSequenceId }));\r\n                    }\r\n                    // Ignore errors, that means the connection is closed and we don't care about the Ack message anymore.\r\n                }\r\n                catch { }\r\n                clearTimeout(this._ackTimerHandle);\r\n                this._ackTimerHandle = undefined;\r\n                // 1 second delay so we don't spam Ack messages if there are many messages being received at once.\r\n            }, 1000);\r\n        }\r\n    }\r\n}\r\nclass BufferedItem {\r\n    constructor(message, id, resolver, rejector) {\r\n        this._message = message;\r\n        this._id = id;\r\n        this._resolver = resolver;\r\n        this._rejector = rejector;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}