{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Alexco/Desktop/proiect .net/Project/Project/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { LogLevel } from \"./ILogger\";\nimport { TransferFormat } from \"./ITransport\";\nimport { Arg, getDataDetail, getUserAgentHeader, Platform, sendMessage } from \"./Utils\";\n/** @private */\nexport class ServerSentEventsTransport {\n  constructor(httpClient, accessToken, logger, options) {\n    this._httpClient = httpClient;\n    this._accessToken = accessToken;\n    this._logger = logger;\n    this._options = options;\n    this.onreceive = null;\n    this.onclose = null;\n  }\n  connect(url, transferFormat) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      Arg.isRequired(url, \"url\");\n      Arg.isRequired(transferFormat, \"transferFormat\");\n      Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\n      _this._logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\");\n      // set url before accessTokenFactory because this._url is only for send and we set the auth header instead of the query string for send\n      _this._url = url;\n      if (_this._accessToken) {\n        url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(_this._accessToken)}`;\n      }\n      return new Promise((resolve, reject) => {\n        let opened = false;\n        if (transferFormat !== TransferFormat.Text) {\n          reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\n          return;\n        }\n        let eventSource;\n        if (Platform.isBrowser || Platform.isWebWorker) {\n          eventSource = new _this._options.EventSource(url, {\n            withCredentials: _this._options.withCredentials\n          });\n        } else {\n          // Non-browser passes cookies via the dictionary\n          const cookies = _this._httpClient.getCookieString(url);\n          const headers = {};\n          headers.Cookie = cookies;\n          const [name, value] = getUserAgentHeader();\n          headers[name] = value;\n          eventSource = new _this._options.EventSource(url, {\n            withCredentials: _this._options.withCredentials,\n            headers: {\n              ...headers,\n              ..._this._options.headers\n            }\n          });\n        }\n        try {\n          eventSource.onmessage = e => {\n            if (_this.onreceive) {\n              try {\n                _this._logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, _this._options.logMessageContent)}.`);\n                _this.onreceive(e.data);\n              } catch (error) {\n                _this._close(error);\n                return;\n              }\n            }\n          };\n          // @ts-ignore: not using event on purpose\n          eventSource.onerror = e => {\n            // EventSource doesn't give any useful information about server side closes.\n            if (opened) {\n              _this._close();\n            } else {\n              reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\" + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\" + \" If you have multiple servers check that sticky sessions are enabled.\"));\n            }\n          };\n          eventSource.onopen = () => {\n            _this._logger.log(LogLevel.Information, `SSE connected to ${_this._url}`);\n            _this._eventSource = eventSource;\n            opened = true;\n            resolve();\n          };\n        } catch (e) {\n          reject(e);\n          return;\n        }\n      });\n    })();\n  }\n  send(data) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this2._eventSource) {\n        return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\n      }\n      return sendMessage(_this2._logger, \"SSE\", _this2._httpClient, _this2._url, data, _this2._options);\n    })();\n  }\n  stop() {\n    this._close();\n    return Promise.resolve();\n  }\n  _close(e) {\n    if (this._eventSource) {\n      this._eventSource.close();\n      this._eventSource = undefined;\n      if (this.onclose) {\n        this.onclose(e);\n      }\n    }\n  }\n}","map":{"version":3,"names":["LogLevel","TransferFormat","Arg","getDataDetail","getUserAgentHeader","Platform","sendMessage","ServerSentEventsTransport","constructor","httpClient","accessToken","logger","options","_httpClient","_accessToken","_logger","_options","onreceive","onclose","connect","url","transferFormat","isRequired","isIn","log","Trace","_url","indexOf","encodeURIComponent","Promise","resolve","reject","opened","Text","Error","eventSource","isBrowser","isWebWorker","EventSource","withCredentials","cookies","getCookieString","headers","Cookie","name","value","onmessage","e","data","logMessageContent","error","_close","onerror","onopen","Information","_eventSource","send","stop","close","undefined"],"sources":["C:/Users/Alexco/Desktop/proiect .net/Project/Project/ClientApp/node_modules/@microsoft/signalr/dist/esm/ServerSentEventsTransport.js"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform, sendMessage } from \"./Utils\";\r\n/** @private */\r\nexport class ServerSentEventsTransport {\r\n    constructor(httpClient, accessToken, logger, options) {\r\n        this._httpClient = httpClient;\r\n        this._accessToken = accessToken;\r\n        this._logger = logger;\r\n        this._options = options;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n    async connect(url, transferFormat) {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\");\r\n        // set url before accessTokenFactory because this._url is only for send and we set the auth header instead of the query string for send\r\n        this._url = url;\r\n        if (this._accessToken) {\r\n            url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(this._accessToken)}`;\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            let opened = false;\r\n            if (transferFormat !== TransferFormat.Text) {\r\n                reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\r\n                return;\r\n            }\r\n            let eventSource;\r\n            if (Platform.isBrowser || Platform.isWebWorker) {\r\n                eventSource = new this._options.EventSource(url, { withCredentials: this._options.withCredentials });\r\n            }\r\n            else {\r\n                // Non-browser passes cookies via the dictionary\r\n                const cookies = this._httpClient.getCookieString(url);\r\n                const headers = {};\r\n                headers.Cookie = cookies;\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n                eventSource = new this._options.EventSource(url, { withCredentials: this._options.withCredentials, headers: { ...headers, ...this._options.headers } });\r\n            }\r\n            try {\r\n                eventSource.onmessage = (e) => {\r\n                    if (this.onreceive) {\r\n                        try {\r\n                            this._logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, this._options.logMessageContent)}.`);\r\n                            this.onreceive(e.data);\r\n                        }\r\n                        catch (error) {\r\n                            this._close(error);\r\n                            return;\r\n                        }\r\n                    }\r\n                };\r\n                // @ts-ignore: not using event on purpose\r\n                eventSource.onerror = (e) => {\r\n                    // EventSource doesn't give any useful information about server side closes.\r\n                    if (opened) {\r\n                        this._close();\r\n                    }\r\n                    else {\r\n                        reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\"\r\n                            + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\"\r\n                            + \" If you have multiple servers check that sticky sessions are enabled.\"));\r\n                    }\r\n                };\r\n                eventSource.onopen = () => {\r\n                    this._logger.log(LogLevel.Information, `SSE connected to ${this._url}`);\r\n                    this._eventSource = eventSource;\r\n                    opened = true;\r\n                    resolve();\r\n                };\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n                return;\r\n            }\r\n        });\r\n    }\r\n    async send(data) {\r\n        if (!this._eventSource) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this._logger, \"SSE\", this._httpClient, this._url, data, this._options);\r\n    }\r\n    stop() {\r\n        this._close();\r\n        return Promise.resolve();\r\n    }\r\n    _close(e) {\r\n        if (this._eventSource) {\r\n            this._eventSource.close();\r\n            this._eventSource = undefined;\r\n            if (this.onclose) {\r\n                this.onclose(e);\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}